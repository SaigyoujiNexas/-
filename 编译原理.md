# 引论

## 语言处理器

1.  编译器： 通过将高级语言翻译成低级语言实现
2. 解释器： 直接利用用户提供的输入执行源程序指定的操作。
3. 预处理器(preprocessor): 将多模块代码进行聚合， 处理宏。
4. 汇编器( assembler)： 处理编译生成的汇编，生成可重定位的机器代码
5. 链接器(linker)： 解决外部内存地址的问题
6. 加载器(loader): 把可执行目标文件放到内存中执行

## 编译器结构

1. 分析(analyis)把源程序分解成多个组成要素， 并在要素上加上语法结构。
2. 综合(synthesis)根据生成的中间表示和符号表信息构造目标程序

**分析部分称为前端（front end）， 综合部分称之为后端(back end)**

### 词法分析

编译器执行的第一步。

词法分析器读入组成源程序的字符流， 并将其组织成为有意义的**词素(lexeme)**的集合

```
<token-name, attribute-value>
```

生成的词法单元传送给下一个步骤， 即语法分析。

### 语法分析

语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。

常用的一个中间表示方法是**语法树(syntax tree)**

### 语义分析

语义分析器(semantic analyer)使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。

语义分析的一个重要部分是**类型检查(type checking)**

### 中间代码生成

语法树通常在语法分析和语义分析中使用

后续很多编译器会生成一个低级语言的中间表示

### 代码优化

例如编译时期就将60转换为60.0， 避免inttofloat函数调用

###  代码生成

以源程序中间表示作为输入， 并将其映射到目标语言

### 符号表管理

符号表数据结构为每一个变量创建条目。

### 将多个步骤组合成躺

每趟读入一个文件并产生一个输出文件

# 简单的语法制导翻译器

## 语法定义

文法自然的描述了大多数程序设计语言的层次化语法结构。

例如、

```
stmt -> if ( expr ) stmt else stmt
```

### 文法定义

一个上下文无关文法(context-free grammar)由四个元素组成：

1. 一个终结符号集合
2. 一个非终结符号集合
3. 一个产生式集合
4. 指定一个非终结符号作为开始符号